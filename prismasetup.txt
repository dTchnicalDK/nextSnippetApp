âœ… Prisma v7 + SQLite with Next.js (TypeScript)
âœ… Step 1: Create Next.js App with TypeScript

If already created, skip.

npx create-next-app@latest my-app --typescript
cd my-app


Check it runs:

npm run dev

âœ… Step 2: Install Prisma v7 + Client
npm install prisma@latest @prisma/client@latest


Verify:

npx prisma -v

âœ… Step 3: Initialize Prisma with SQLite
npx prisma init --datasource-provider sqlite


Creates:

prisma/
 â””â”€â”€ schema.prisma
.env

âœ… Step 4: Configure .env
DATABASE_URL="file:./dev.db"


SQLite DB will live in prisma/dev.db.

âœ… Step 5: Update schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
}

âœ… Step 6: Run Migration
npx prisma migrate dev --name init


âœ” Creates database
âœ” Generates Prisma Client

âœ… Step 7: Create Prisma Client Helper (TypeScript-safe)
ğŸ“„ src/lib/prisma.ts (recommended)
import { PrismaClient } from "@prisma/client";

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma =
  globalForPrisma.prisma ??
  new PrismaClient({
    log: ["query", "error"],
  });

if (process.env.NODE_ENV !== "production") {
  globalForPrisma.prisma = prisma;
}


âœ… Fixes hot-reload issue
âœ… Full TypeScript safety

âœ… Step 8: Use Prisma in Server Component (TypeScript)
ğŸ“„ src/app/page.tsx
import { prisma } from "@/lib/prisma";

export default async function Home() {
  const users = await prisma.user.findMany();

  return (
    <main>
      <h1>Users</h1>
      <pre>{JSON.stringify(users, null, 2)}</pre>
    </main>
  );
}

âœ… Step 9: Use Prisma in API Route (TypeScript)
ğŸ“„ src/app/api/users/route.ts
import { prisma } from "@/lib/prisma";
import { NextResponse } from "next/server";

export async function GET() {
  const users = await prisma.user.findMany();
  return NextResponse.json(users);
}

export async function POST(req: Request) {
  const body = await req.json();

  const user = await prisma.user.create({
    data: {
      email: body.email,
      name: body.name,
    },
  });

  return NextResponse.json(user);
}

âœ… Step 10: Prisma Studio
npx prisma studio


Visual DB editor (works great with SQLite).

âœ… Step 11: Type Safety Example (Why Prisma + TS is ğŸ”¥)
const user = await prisma.user.create({
  data: {
    email: "test@mail.com",
    // name: 123 âŒ TypeScript error
  },
});

âš ï¸ Important Rules (Next.js + Prisma)
Rule	Why
Prisma is server-only	Never import in client components
Use singleton client	Avoid too many DB connections
Use src/lib/prisma.ts	Clean architecture
SQLite is local-only	Not good for production
ğŸ§  Next Logical Steps (Recommended for You)

Since youâ€™re aiming to become full-stack + job-ready, I strongly suggest next:

ğŸ” Auth (NextAuth / JWT)

ğŸ“¦ Relations (User â†” Post)

ğŸ”„ Server Actions + Prisma

ğŸš€ PostgreSQL migration

ğŸŒ Deploy on Vercel

If you want, next I can:

Build a full CRUD blog app

Add Auth with Prisma

Convert SQLite â†’ PostgreSQL

Explain Prisma relations visually

Just say what you want next ğŸ‘Œ

npx prisma migrate dev --name init

what it does

Good question ğŸ‘
Letâ€™s clearly understand what this command does:

npx prisma migrate dev --name init

ğŸ” What prisma migrate dev does (step-by-step)
1ï¸âƒ£ Reads your schema.prisma

Prisma checks:

Models (User, Post, etc.)

Fields, types, relations

Datasource (SQLite in your case)

2ï¸âƒ£ Creates a migration file

It generates a folder like:

prisma/
 â””â”€â”€ migrations/
     â””â”€â”€ 20251215123045_init/
         â””â”€â”€ migration.sql


ğŸ“Œ This SQL file contains:

CREATE TABLE "User" (
  "id" INTEGER PRIMARY KEY AUTOINCREMENT,
  "email" TEXT NOT NULL UNIQUE,
  "name" TEXT
);


â¡ï¸ This is the actual SQL Prisma will run.

3ï¸âƒ£ Applies the migration to the database

For SQLite:

Creates prisma/dev.db (if not exists)

Runs the SQL inside migration.sql

Tables are physically created

4ï¸âƒ£ Generates Prisma Client

It automatically runs:

npx prisma generate


This creates:

node_modules/@prisma/client


Now TypeScript knows:

prisma.user.findMany()

prisma.user.create()

field types & autocomplete

5ï¸âƒ£ Saves migration history

Prisma tracks applied migrations in:

_prisma_migrations table


So Prisma knows:

What ran

In which order

Prevents re-running the same migration

ğŸ·ï¸ What does --name init mean?
--name init


Just a label

Used for readability

You can name it anything

Examples:

--name add-user-table
--name add-post-model
--name update-relations

ğŸ§  In simple words

Think of it like this:

prisma migrate dev =
â€œConvert my Prisma schema into SQL, create/update my database, and keep history.â€

ğŸ†š migrate dev vs db push
Command	Purpose
migrate dev	Schema changes with history (best for teams)
db push	Quick sync without history
migrate reset	Wipe DB & re-run all migrations
ğŸš« Common Beginner Mistakes

âŒ Thinking it only creates DB
âœ” It also creates SQL + client + history

âŒ Running it on every start
âœ” Run only when schema changes

ğŸ§ª When YOU should run it

You run:

npx prisma migrate dev


âœ… After:

Adding a model

Adding a field

Changing relations

âŒ Not for:

Reading data

Querying DB

Runtime usage

If you want, I can next explain:

ğŸ” What happens when you edit schema later

ğŸ§© Difference between migration & generate

ğŸ§  How Prisma knows TypeScript types

ğŸ—ƒï¸ How SQLite file is actually created

Just tell me ğŸ‘


